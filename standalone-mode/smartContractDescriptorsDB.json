[{"name": "MetaCoin", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "MetaCoin", "author": "Author Here", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "addr", "type": "address"}], "name": "getBalanceInEth", "outputs": [{"name": "value", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "receiver", "type": "address"}, {"name": "amount", "type": "uint256"}], "name": "sendCoin", "outputs": [{"name": "sufficient", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "addr", "type": "address"}], "name": "getBalance", "outputs": [{"name": "value", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "_from", "type": "address"}, {"indexed": true, "name": "_to", "type": "address"}, {"indexed": false, "name": "_value", "type": "uint256"}], "name": "Transfer", "type": "event"}], "userdoc": {"methods": {"getBalance(address)": {"notice": "Returns MetaCoin balance for a given address"}, "getBalanceInEth(address)": {"notice": "Returns equivalent Ether balance for a given address"}, "sendCoin(address,uint256)": {"notice": "Transfer coins from sender to receiver"}}}}, "endpoint": {}, "dev": {"devdoc": {"author": "Author Here", "methods": {"getBalance(address)": {"return": "{ \"value\" : \"Token balance of account\" }"}, "getBalanceInEth(address)": {"details": "Uses the `ConvertLib.sol` library for conversions", "return": "{ \"value\" : \"Ether equivalent balance of account\" }"}, "sendCoin(address,uint256)": {"details": "This is just a simple example of a coin-like contract. It is not standards compatible and cannot be expected to talk to other coin/token contracts. If you want to create a standards-compliant token, see: [ConsenSys/Tokens](https://github.com/ConsenSys/Tokens). Cheers!", "return": "{ \"sufficient\": \"Transfer is succesful\" }"}}, "title": "MetaCoin Interface"}, "sources": {"keccak256": "0xf583c580ac981029f63ec3e39bd97b6955eb91241d6f066897268c12e3412b98", "swarm_URL": "bzzr://d9a33154f48e2d75ec875dcaeff392fce12866a45855d04a3e4d0aaa7af9fe5b"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\nimport \"./ConvertLib.sol\";\n\n/**\n@title MetaCoin Interface\n@author Author Here\n@dev TODO update solidity compiler to add user/dev notes\n*/\ncontract MetaCoin {\n\n\t// TODO update solidity compiler to support variable definitions\n\tmapping (address => uint) balances;\n\n\t// TODO update solidity compiler to support events\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\t// TODO update solidity compiler to support constructor\n\tfunction MetaCoin() {\n\t\tbalances[tx.origin] = 10000;\n\t}\n\n\t/**\n\t@notice Transfer coins from sender to receiver\n\t@dev\n\t\tThis is just a simple example of a coin-like contract.\n\t\tIt is not standards compatible and cannot be expected to talk to other\n\t\tcoin/token contracts. If you want to create a standards-compliant\n\t\ttoken, see: [ConsenSys/Tokens](https://github.com/ConsenSys/Tokens). Cheers!\n\t@param receiver Address of the receipient\n\t@param amount Amount of tokens to send\n\t@return { \"sufficient\": \"Transfer is succesful\" }\n\t*/\n\tfunction sendCoin(address receiver, uint amount) returns (bool sufficient) {\n\t\tif (balances[msg.sender] < amount) return false;\n\t\tbalances[msg.sender] -= amount;\n\t\tbalances[receiver] += amount;\n\t\tTransfer(msg.sender, receiver, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t@notice Returns equivalent Ether balance for a given address\n\t@dev Uses the `ConvertLib.sol` library for conversions\n\t@param addr Queried address\n\t@return { \"value\" : \"Ether equivalent balance of account\" }\n\t*/\n\tfunction getBalanceInEth(address addr) returns(uint value){\n\t\treturn ConvertLib.convert(getBalance(addr),2);\n\t}\n\t/**\n\t@notice Returns MetaCoin balance for a given address\n\t@param addr Queried address\n\t@return { \"value\" : \"Token balance of account\" }\n\t*/\n\tfunction getBalance(address addr) returns(uint value) {\n\t\treturn balances[addr];\n\t}\n}\n"}, {"name": "Set", "contract_type": "library", "JSON": {"contract": {"descriptor": {"name": "Set", "author": "", "language": "Solidity", "contract_type": "library", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "remove", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "contains", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "insert", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {}}, "sources": {"keccak256": "0xef39e446d16b4f599454fe120cd7345d3c8819c25da421de60e20d9c3efefb11", "swarm_URL": "bzzr://71aa9deb4400e7201428d0715cbc343b778a14f7c50e6272ee4bd1d15a007fa4"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.16;\n\nlibrary Set {\n  // We define a new struct datatype that will be used to\n  // hold its data in the calling contract.\n  struct Data { mapping(uint => bool) flags; }\n\n  // Note that the first parameter is of type \"storage\n  // reference\" and thus only its storage address and not\n  // its contents is passed as part of the call.  This is a\n  // special feature of library functions.  It is idiomatic\n  // to call the first parameter `self`, if the function can\n  // be seen as a method of that object.\n  function insert(Data storage self, uint value)\n      public\n      returns (bool)\n  {\n      if (self.flags[value])\n          return false; // already there\n      self.flags[value] = true;\n      return true;\n  }\n\n  function remove(Data storage self, uint value)\n      public\n      returns (bool)\n  {\n      if (!self.flags[value])\n          return false; // not there\n      self.flags[value] = false;\n      return true;\n  }\n\n  function contains(Data storage self, uint value)\n      public\n      view\n      returns (bool)\n  {\n      return self.flags[value];\n  }\n}\n"}, {"name": "SafeMath", "contract_type": "library", "JSON": {"contract": {"descriptor": {"name": "SafeMath", "author": "", "language": "Solidity", "contract_type": "library", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "x", "type": "uint256"}], "name": "sq", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "x", "type": "uint256"}], "name": "sqrt", "outputs": [{"name": "y", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "add", "outputs": [{"name": "c", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "div", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "sub", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "mul", "outputs": [{"name": "c", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "x", "type": "uint256"}, {"name": "y", "type": "uint256"}], "name": "pwr", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {"address": "0x6d83485ae971ab2151f898db2bd862ec69020a28", "networkID": 1, "chainID": 1}, "dev": {"devdoc": {"methods": {"add(uint256,uint256)": {"details": "Adds two numbers, throws on overflow."}, "div(uint256,uint256)": {"details": "Integer division of two numbers, truncating the quotient."}, "mul(uint256,uint256)": {"details": "Multiplies two numbers, throws on overflow."}, "pwr(uint256,uint256)": {"details": "x to the power of y"}, "sq(uint256)": {"details": "gives square. multiplies x by x"}, "sqrt(uint256)": {"details": "gives square root of given x."}, "sub(uint256,uint256)": {"details": "Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend)."}}, "title": "SafeMath v0.1.9"}, "sources": {"keccak256": "0xdab2c22fa232d505bbf399a2e38d82878d364ed73b8d5dfcd95e9b949da3bfb4", "swarm_URL": "bzzr://ddf836809129e2d326d236f42c0e62522670f18f5072db32f67000ad0735a491"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.24;\n\n/**\n * @title SafeMath v0.1.9\n * @dev Math operations with safety checks that throw on error\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n * - added sqrt\n * - added sq\n * - added pwr\n * - changed asserts to requires with error log outputs\n * - removed div, its useless\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b)\n        returns (uint256 c)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b, \"SafeMath mul failed\");\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b)\n        returns (uint256)\n    {\n        require(b <= a, \"SafeMath sub failed\");\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b)\n        returns (uint256 c)\n    {\n        c = a + b;\n        require(c >= a, \"SafeMath add failed\");\n        return c;\n    }\n\n    /**\n     * @dev gives square root of given x.\n     */\n    function sqrt(uint256 x)\n        returns (uint256 y)\n    {\n        uint256 z = ((add(x,1)) / 2);\n        y = x;\n        while (z < y)\n        {\n            y = z;\n            z = ((add((x / z),z)) / 2);\n        }\n    }\n\n    /**\n     * @dev gives square. multiplies x by x\n     */\n    function sq(uint256 x)\n        returns (uint256)\n    {\n        return (mul(x,x));\n    }\n\n    /**\n     * @dev x to the power of y\n     */\n    function pwr(uint256 x, uint256 y)\n        returns (uint256)\n    {\n        if (x==0)\n            return (0);\n        else if (y==0)\n            return (1);\n        else\n        {\n            uint256 z = x;\n            for (uint256 i=1; i < y; i++)\n                z = mul(z,x);\n            return (z);\n        }\n    }\n}"}, {"name": "Heritable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Heritable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "claimHeirOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_newHeir", "type": "address"}], "name": "setHeir", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "proclaimDeath", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "heartbeat", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "heartbeatTimeout", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [], "name": "heir", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "timeOfDeath", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "removeHeir", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"name": "_heartbeatTimeout", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "owner", "type": "address"}, {"indexed": true, "name": "newHeir", "type": "address"}], "name": "HeirChanged", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "owner", "type": "address"}], "name": "OwnerHeartbeated", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "owner", "type": "address"}, {"indexed": true, "name": "heir", "type": "address"}, {"indexed": false, "name": "timeOfDeath", "type": "uint256"}], "name": "OwnerProclaimedDead", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "HeirOwnershipClaimed", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"claimHeirOwnership()": {"details": "Allows heir to transfer ownership only if heartbeat has timed out."}, "heartbeat()": {"details": "Owner can send a heartbeat if they were mistakenly pronounced dead."}, "heir()": {"details": "Use these getter functions to access the internal variables in an inherited contract."}, "proclaimDeath()": {"details": "Heir can pronounce the owners death. To claim the ownership, they will have to wait for `heartbeatTimeout` seconds."}, "removeHeir()": {"details": "set heir = 0x0"}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "Heritable"}, "sources": {"keccak256": "0x11f28ce5d4fccbf184fdb75be6774085f77f242adb931c7c36410555af179540", "swarm_URL": "bzzr://67b8a04d604596e6a71244be66f8062fede7cf2792801ca35157dea121097b35"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.24;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Heritable\n * @dev The Heritable contract provides ownership transfer capabilities, in the\n * case that the current owner stops \"heartbeating\". Only the heir can pronounce the\n * owner's death.\n */\ncontract Heritable is Ownable {\n  address private heir_;\n\n  // Time window the owner has to notify they are alive.\n  uint256 private heartbeatTimeout_;\n\n  // Timestamp of the owner's death, as pronounced by the heir.\n  uint256 private timeOfDeath_;\n\n  event HeirChanged(address indexed owner, address indexed newHeir);\n  event OwnerHeartbeated(address indexed owner);\n  event OwnerProclaimedDead(\n    address indexed owner,\n    address indexed heir,\n    uint256 timeOfDeath\n  );\n  event HeirOwnershipClaimed(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev Throw an exception if called by any account other than the heir's.\n   */\n  modifier onlyHeir() {\n    require(msg.sender == heir_);\n    _;\n  }\n\n\n  /**\n   * @notice Create a new Heritable Contract with heir address 0x0.\n   * @param _heartbeatTimeout time available for the owner to notify they are alive,\n   * before the heir can take ownership.\n   */\n  constructor(uint256 _heartbeatTimeout) public {\n    heartbeatTimeout_ = _heartbeatTimeout;\n  }\n\n  function setHeir(address _newHeir) public onlyOwner {\n    require(_newHeir != owner);\n    heartbeat();\n    emit HeirChanged(owner, _newHeir);\n    heir_ = _newHeir;\n  }\n\n  /**\n   * @dev Use these getter functions to access the internal variables in\n   * an inherited contract.\n   */\n  function heir() public returns(address) {\n    return heir_;\n  }\n\n  function heartbeatTimeout() public returns(uint256) {\n    return heartbeatTimeout_;\n  }\n\n  function timeOfDeath() public returns(uint256) {\n    return timeOfDeath_;\n  }\n\n  /**\n   * @dev set heir = 0x0\n   */\n  function removeHeir() public onlyOwner {\n    heartbeat();\n    heir_ = address(0);\n  }\n\n  /**\n   * @dev Heir can pronounce the owners death. To claim the ownership, they will\n   * have to wait for `heartbeatTimeout` seconds.\n   */\n  function proclaimDeath() public onlyHeir {\n    require(ownerLives());\n    emit OwnerProclaimedDead(owner, heir_, timeOfDeath_);\n    // solium-disable-next-line security/no-block-members\n    timeOfDeath_ = block.timestamp;\n  }\n\n  /**\n   * @dev Owner can send a heartbeat if they were mistakenly pronounced dead.\n   */\n  function heartbeat() public onlyOwner {\n    emit OwnerHeartbeated(owner);\n    timeOfDeath_ = 0;\n  }\n\n  /**\n   * @dev Allows heir to transfer ownership only if heartbeat has timed out.\n   */\n  function claimHeirOwnership() public onlyHeir {\n    require(!ownerLives());\n    // solium-disable-next-line security/no-block-members\n    require(block.timestamp >= timeOfDeath_ + heartbeatTimeout_);\n    emit OwnershipTransferred(owner, heir_);\n    emit HeirOwnershipClaimed(owner, heir_);\n    owner = heir_;\n    timeOfDeath_ = 0;\n  }\n\n  function ownerLives() private returns (bool) {\n    return timeOfDeath_ == 0;\n  }\n}\n"}, {"name": "Claimable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Claimable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "claimOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [], "name": "pendingOwner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"claimOwnership()": {"details": "Allows the pendingOwner address to finalize the transfer."}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to set the pendingOwner address."}}, "title": "Claimable"}, "sources": {"keccak256": "0xbee545b3c31874580e790f0cb74865fd2bb28086d08d17c7f50857eddf072c77", "swarm_URL": "bzzr://98f1c4b8de8be45b42d29c1f35bcb89fbe8116ae6f269f488e6c4e5ce9f24d1c"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract Claimable is Ownable {\n  address public pendingOwner;\n\n  /**\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n   */\n  modifier onlyPendingOwner() {\n    require(msg.sender == pendingOwner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to set the pendingOwner address.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev Allows the pendingOwner address to finalize the transfer.\n   */\n  function claimOwnership() onlyPendingOwner public {\n    emit OwnershipTransferred(owner, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n}\n"}, {"name": "usingOraclize", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "usingOraclize", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": true, "inputs": [{"name": "_a", "type": "string"}], "name": "parseInt", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_haystack", "type": "string"}, {"name": "_needle", "type": "string"}], "name": "indexOf", "outputs": [{"name": "", "type": "int256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}, {"name": "_b", "type": "string"}, {"name": "_c", "type": "string"}, {"name": "_d", "type": "string"}, {"name": "_e", "type": "string"}], "name": "strConcat", "outputs": [{"name": "", "type": "string"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}], "name": "parseAddr", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}, {"name": "_b", "type": "string"}], "name": "strCompare", "outputs": [{"name": "", "type": "int256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "i", "type": "uint256"}], "name": "uint2str", "outputs": [{"name": "", "type": "string"}], "payable": false, "stateMutability": "view", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {}}, "sources": {"keccak256": "0x970de26986f1bed3409b9aa50474f0b68ae9495a4bd8799dd23e70dec50cc8b4", "swarm_URL": "bzzr://edadb35d0cf13a24f97519bf271dfb9c021d31e6a9d9df6c42378b97f5691c03"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize SRL\nCopyright (c) 2016 Oraclize LTD\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n\n/* SUBSET OF ORACLIZE_API FUNCTIONS */\n\ncontract usingOraclize {\n\n    function parseAddr(string _a) constant returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) constant returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) constant returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) constant returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    // parseInt\n    function parseInt(string _a) constant returns (uint) {\n        uint _b = 0;\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) constant returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n}\n// </ORACLIZE_API>\n"}, {"name": "Destructible", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Destructible", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "destroy", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_recipient", "type": "address"}], "name": "destroyAndSend", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": true, "stateMutability": "payable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"destroy()": {"details": "Transfers the current balance to the owner and terminates the contract."}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "Destructible"}, "sources": {"keccak256": "0x8993ad0305609605827d7b95764edcc60147ae44d467370cfb43499916b052a3", "swarm_URL": "bzzr://a37b8d8085a4016a9c761cad19e01050595ec8454d1989141a11e7a49f440c56"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Destructible\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n */\ncontract Destructible is Ownable {\n\n  constructor() public payable { }\n\n  /**\n   * @dev Transfers the current balance to the owner and terminates the contract.\n   */\n  function destroy() onlyOwner public {\n    selfdestruct(owner);\n  }\n\n  function destroyAndSend(address _recipient) onlyOwner public {\n    selfdestruct(_recipient);\n  }\n}\n"}, {"name": "SimpleSavingsWallet", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "SimpleSavingsWallet", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "claimHeirOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_newHeir", "type": "address"}], "name": "setHeir", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "proclaimDeath", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "heartbeat", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "heartbeatTimeout", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [], "name": "heir", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_payee", "type": "address"}, {"name": "_amount", "type": "uint256"}], "name": "sendTo", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "timeOfDeath", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "removeHeir", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [{"name": "_heartbeatTimeout", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"payable": true, "stateMutability": "payable", "type": "fallback"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "payee", "type": "address"}, {"indexed": false, "name": "amount", "type": "uint256"}, {"indexed": false, "name": "balance", "type": "uint256"}], "name": "Sent", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "payer", "type": "address"}, {"indexed": false, "name": "amount", "type": "uint256"}, {"indexed": false, "name": "balance", "type": "uint256"}], "name": "Received", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "owner", "type": "address"}, {"indexed": true, "name": "newHeir", "type": "address"}], "name": "HeirChanged", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "owner", "type": "address"}], "name": "OwnerHeartbeated", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "owner", "type": "address"}, {"indexed": true, "name": "heir", "type": "address"}, {"indexed": false, "name": "timeOfDeath", "type": "uint256"}], "name": "OwnerProclaimedDead", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "HeirOwnershipClaimed", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"claimHeirOwnership()": {"details": "Allows heir to transfer ownership only if heartbeat has timed out."}, "heartbeat()": {"details": "Owner can send a heartbeat if they were mistakenly pronounced dead."}, "heir()": {"details": "Use these getter functions to access the internal variables in an inherited contract."}, "proclaimDeath()": {"details": "Heir can pronounce the owners death. To claim the ownership, they will have to wait for `heartbeatTimeout` seconds."}, "removeHeir()": {"details": "set heir = 0x0"}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "sendTo(address,uint256)": {"details": "wallet can send funds"}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "SimpleSavingsWallet"}, "sources": {"keccak256": "0x11f28ce5d4fccbf184fdb75be6774085f77f242adb931c7c36410555af179540", "swarm_URL": "bzzr://67b8a04d604596e6a71244be66f8062fede7cf2792801ca35157dea121097b35"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.24;\n\nimport \"./Heritable.sol\";\n\n\n/**\n * @title SimpleSavingsWallet\n * @dev Simplest form of savings wallet whose ownership can be claimed by a heir\n * if owner dies.\n * In this example, we take a very simple savings wallet providing two operations\n * (to send and receive funds) and extend its capabilities by making it Heritable.\n * The account that creates the contract is set as owner, who has the authority to\n * choose an heir account. Heir account can reclaim the contract ownership in the\n * case that the owner dies.\n */\ncontract SimpleSavingsWallet is Heritable {\n\n  event Sent(address indexed payee, uint256 amount, uint256 balance);\n  event Received(address indexed payer, uint256 amount, uint256 balance);\n\n\n  constructor(uint256 _heartbeatTimeout) Heritable(_heartbeatTimeout) public {}\n\n  /**\n   * @dev wallet can receive funds.\n   */\n  function () external payable {\n    emit Received(msg.sender, msg.value, address(this).balance);\n  }\n\n  /**\n   * @dev wallet can send funds\n   */\n  function sendTo(address _payee, uint256 _amount) public onlyOwner {\n    require(_payee != address(0) && _payee != address(this));\n    require(_amount > 0);\n    _payee.transfer(_amount);\n    emit Sent(_payee, _amount, address(this).balance);\n  }\n}\n"}, {"name": "ConvertLib", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "ConvertLib", "author": "Joe Bloggs", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "amount", "type": "uint256"}, {"name": "conversionRate", "type": "uint256"}], "name": "convert", "outputs": [{"name": "convertedAmount", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {"convert(uint256,uint256)": {"notice": "Converts given value to Ether value"}}}}, "endpoint": {}, "dev": {"devdoc": {"author": "Joe Bloggs", "methods": {"convert(uint256,uint256)": {"return": "{ \"convertedAmount\" : \"Ether equivalent amount\" }"}}, "title": "Convert-o-matic 2000"}, "sources": {"keccak256": "0xf583c580ac981029f63ec3e39bd97b6955eb91241d6f066897268c12e3412b98", "swarm_URL": "bzzr://d9a33154f48e2d75ec875dcaeff392fce12866a45855d04a3e4d0aaa7af9fe5b"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\n/**\n@title Convert-o-matic 2000\n@author Joe Bloggs\n*/\nlibrary ConvertLib{\n\t/**\n\t@notice Converts given value to Ether value\n\t@param amount Token amount\n\t@param conversionRate Rate of conversion - Tokens -> Ether\n\t@return { \"convertedAmount\" : \"Ether equivalent amount\" }\n\t*/\n\tfunction convert(uint amount, uint conversionRate) returns (uint convertedAmount)\n\t{\n\t\treturn amount * conversionRate;\n\t}\n}\n"}, {"name": "Pausable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Pausable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "unpause", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "paused", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "pause", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [], "name": "Pause", "type": "event"}, {"anonymous": false, "inputs": [], "name": "Unpause", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"pause()": {"details": "called by the owner to pause, triggers stopped state"}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}, "unpause()": {"details": "called by the owner to unpause, returns to normal state"}}, "title": "Pausable"}, "sources": {"keccak256": "0x84c7090c27cf3657b73d9e26b6b316975fa0bd233b8169f254de0c3b3acfaefc", "swarm_URL": "bzzr://b983355647976c1daa5de581a1b6a41be9c5adc17cce257b8679649db78f8a11"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n"}, {"name": "Escrow", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Escrow", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "_payee", "type": "address"}], "name": "withdraw", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_payee", "type": "address"}], "name": "depositsOf", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_payee", "type": "address"}], "name": "deposit", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "payee", "type": "address"}, {"indexed": false, "name": "weiAmount", "type": "uint256"}], "name": "Deposited", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "payee", "type": "address"}, {"indexed": false, "name": "weiAmount", "type": "uint256"}], "name": "Withdrawn", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"deposit(address)": {"details": "Stores the sent amount as credit to be withdrawn."}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}, "withdraw(address)": {"details": "Withdraw accumulated balance for a payee."}}, "title": "Escrow"}, "sources": {"keccak256": "0x490fc809152a1ed111f9f13e485e3f9cb3ed45e6532e1bc6a4e2fae1dc8b0145", "swarm_URL": "bzzr://e7de5490bee95c05b5f4f2ec695c36bfb6275f572c8fe71cba4469422ee65a07"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Escrow\n * @dev Base escrow contract, holds funds destinated to a payee until they\n * withdraw them. The contract that uses the escrow as its payment method\n * should be its owner, and provide public methods redirecting to the escrow's\n * deposit and withdraw.\n */\ncontract Escrow is Ownable {\n  using SafeMath for uint256;\n\n  event Deposited(address indexed payee, uint256 weiAmount);\n  event Withdrawn(address indexed payee, uint256 weiAmount);\n\n  mapping(address => uint256) private deposits;\n\n  function depositsOf(address _payee) public view returns (uint256) {\n    return deposits[_payee];\n  }\n\n  /**\n  * @dev Stores the sent amount as credit to be withdrawn.\n  * @param _payee The destination address of the funds.\n  */\n  function deposit(address _payee) public onlyOwner payable {\n    uint256 amount = msg.value;\n    deposits[_payee] = deposits[_payee].add(amount);\n\n    emit Deposited(_payee, amount);\n  }\n\n  /**\n  * @dev Withdraw accumulated balance for a payee.\n  * @param _payee The address whose funds will be withdrawn and transferred to.\n  */\n  function withdraw(address _payee) public onlyOwner {\n    uint256 payment = deposits[_payee];\n    assert(address(this).balance >= payment);\n\n    deposits[_payee] = 0;\n\n    _payee.transfer(payment);\n\n    emit Withdrawn(_payee, payment);\n  }\n}\n"}, {"name": "Ownable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Ownable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "Ownable"}, "sources": {"keccak256": "0x84c7090c27cf3657b73d9e26b6b316975fa0bd233b8169f254de0c3b3acfaefc", "swarm_URL": "bzzr://b983355647976c1daa5de581a1b6a41be9c5adc17cce257b8679649db78f8a11"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"}, {"name": "Contactable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Contactable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": true, "inputs": [], "name": "contactInformation", "outputs": [{"name": "", "type": "string"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_info", "type": "string"}], "name": "setContactInformation", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "setContactInformation(string)": {"details": "Allows the owner to set a string with their contact information."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "Contactable token"}, "sources": {"keccak256": "0x73abe0c002ca6d4041de651ddcb1aceb49823c3103756fc0c0f443960fa80035", "swarm_URL": "bzzr://64f67422ee36c6860636d2c9a0ef02090d30d58bcb662a90e71c5291de9ec142"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.24;\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Contactable token\n * @dev Basic version of a contactable contract, allowing the owner to provide a string with their\n * contact information.\n */\ncontract Contactable is Ownable {\n\n  string public contactInformation;\n\n  /**\n    * @dev Allows the owner to set a string with their contact information.\n    * @param _info The contact information to attach to the contract.\n    */\n  function setContactInformation(string _info) public onlyOwner {\n    contactInformation = _info;\n  }\n}\n"}]