[{"name": "MetaCoin", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "MetaCoin", "author": "Author Here", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "addr", "type": "address"}], "name": "getBalanceInEth", "outputs": [{"name": "value", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "receiver", "type": "address"}, {"name": "amount", "type": "uint256"}], "name": "sendCoin", "outputs": [{"name": "sufficient", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "addr", "type": "address"}], "name": "getBalance", "outputs": [{"name": "value", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "_from", "type": "address"}, {"indexed": true, "name": "_to", "type": "address"}, {"indexed": false, "name": "_value", "type": "uint256"}], "name": "Transfer", "type": "event"}], "userdoc": {"methods": {"getBalance(address)": {"notice": "Returns MetaCoin balance for a given address"}, "getBalanceInEth(address)": {"notice": "Returns equivalent Ether balance for a given address"}, "sendCoin(address,uint256)": {"notice": "Transfer coins from sender to receiver"}}}}, "endpoint": {"address": "0x0000000000000000000000000000000000000000", "networkID": 1, "chainID": 1}, "dev": {"devdoc": {"author": "Author Here", "methods": {"getBalance(address)": {"return": "{ \"value\" : \"Token balance of account\" }"}, "getBalanceInEth(address)": {"details": "Uses the `ConvertLib.sol` library for conversions", "return": "{ \"value\" : \"Ether equivalent balance of account\" }"}, "sendCoin(address,uint256)": {"details": "This is just a simple example of a coin-like contract. It is not standards compatible and cannot be expected to talk to other coin/token contracts. If you want to create a standards-compliant token, see: [ConsenSys/Tokens](https://github.com/ConsenSys/Tokens). Cheers!", "return": "{ \"sufficient\": \"Transfer is succesful\" }"}}, "title": "MetaCoin Interface"}, "sources": {"keccak256": "0xf583c580ac981029f63ec3e39bd97b6955eb91241d6f066897268c12e3412b98", "swarm_URL": "bzzr://d9a33154f48e2d75ec875dcaeff392fce12866a45855d04a3e4d0aaa7af9fe5b"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\nimport \"./ConvertLib.sol\";\n\n/**\n@title MetaCoin Interface\n@author Author Here\n@dev TODO update solidity compiler to add user/dev notes\n*/\ncontract MetaCoin {\n\n\t// TODO update solidity compiler to support variable definitions\n\tmapping (address => uint) balances;\n\n\t// TODO update solidity compiler to support events\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\t// TODO update solidity compiler to support constructor\n\tfunction MetaCoin() {\n\t\tbalances[tx.origin] = 10000;\n\t}\n\n\t/**\n\t@notice Transfer coins from sender to receiver\n\t@dev\n\t\tThis is just a simple example of a coin-like contract.\n\t\tIt is not standards compatible and cannot be expected to talk to other\n\t\tcoin/token contracts. If you want to create a standards-compliant\n\t\ttoken, see: [ConsenSys/Tokens](https://github.com/ConsenSys/Tokens). Cheers!\n\t@param receiver Address of the receipient\n\t@param amount Amount of tokens to send\n\t@return { \"sufficient\": \"Transfer is succesful\" }\n\t*/\n\tfunction sendCoin(address receiver, uint amount) returns (bool sufficient) {\n\t\tif (balances[msg.sender] < amount) return false;\n\t\tbalances[msg.sender] -= amount;\n\t\tbalances[receiver] += amount;\n\t\tTransfer(msg.sender, receiver, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t@notice Returns equivalent Ether balance for a given address\n\t@dev Uses the `ConvertLib.sol` library for conversions\n\t@param addr Queried address\n\t@return { \"value\" : \"Ether equivalent balance of account\" }\n\t*/\n\tfunction getBalanceInEth(address addr) returns(uint value){\n\t\treturn ConvertLib.convert(getBalance(addr),2);\n\t}\n\t/**\n\t@notice Returns MetaCoin balance for a given address\n\t@param addr Queried address\n\t@return { \"value\" : \"Token balance of account\" }\n\t*/\n\tfunction getBalance(address addr) returns(uint value) {\n\t\treturn balances[addr];\n\t}\n}\n"}, {"name": "Set", "contract_type": "library", "JSON": {"contract": {"descriptor": {"name": "Set", "author": "", "language": "Solidity", "contract_type": "library", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "remove", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "contains", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "insert", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {}}, "sources": {"keccak256": "0xef39e446d16b4f599454fe120cd7345d3c8819c25da421de60e20d9c3efefb11", "swarm_URL": "bzzr://71aa9deb4400e7201428d0715cbc343b778a14f7c50e6272ee4bd1d15a007fa4"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.16;\n\nlibrary Set {\n  // We define a new struct datatype that will be used to\n  // hold its data in the calling contract.\n  struct Data { mapping(uint => bool) flags; }\n\n  // Note that the first parameter is of type \"storage\n  // reference\" and thus only its storage address and not\n  // its contents is passed as part of the call.  This is a\n  // special feature of library functions.  It is idiomatic\n  // to call the first parameter `self`, if the function can\n  // be seen as a method of that object.\n  function insert(Data storage self, uint value)\n      public\n      returns (bool)\n  {\n      if (self.flags[value])\n          return false; // already there\n      self.flags[value] = true;\n      return true;\n  }\n\n  function remove(Data storage self, uint value)\n      public\n      returns (bool)\n  {\n      if (!self.flags[value])\n          return false; // not there\n      self.flags[value] = false;\n      return true;\n  }\n\n  function contains(Data storage self, uint value)\n      public\n      view\n      returns (bool)\n  {\n      return self.flags[value];\n  }\n}\n"}, {"name": "SafeMath", "contract_type": "library", "JSON": {"contract": {"descriptor": {"name": "SafeMath", "author": "", "language": "Solidity", "contract_type": "library", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [], "userdoc": {"methods": {}}}, "endpoint": {"address": "0x0000000000000000000000000000000000000000", "networkID": 1, "chainID": 1}, "dev": {"devdoc": {"methods": {}, "title": "SafeMath"}, "sources": {"keccak256": "0x6f859ac66b474844c08916cd628b116978fb0f211489a5f45b1fb4a2f7db56b1", "swarm_URL": "bzzr://761ddde6ebe029775b131a31d4f9d4f1c80f4bae7f13b27421d46fcbc036c662"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n"}, {"name": "Claimable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Claimable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "claimOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [], "name": "pendingOwner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"claimOwnership()": {"details": "Allows the pendingOwner address to finalize the transfer."}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to set the pendingOwner address."}}, "title": "Claimable"}, "sources": {"keccak256": "0xbee545b3c31874580e790f0cb74865fd2bb28086d08d17c7f50857eddf072c77", "swarm_URL": "bzzr://98f1c4b8de8be45b42d29c1f35bcb89fbe8116ae6f269f488e6c4e5ce9f24d1c"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract Claimable is Ownable {\n  address public pendingOwner;\n\n  /**\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n   */\n  modifier onlyPendingOwner() {\n    require(msg.sender == pendingOwner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to set the pendingOwner address.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev Allows the pendingOwner address to finalize the transfer.\n   */\n  function claimOwnership() onlyPendingOwner public {\n    emit OwnershipTransferred(owner, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n}\n"}, {"name": "Pausable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Pausable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "unpause", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "paused", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "pause", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [], "name": "Pause", "type": "event"}, {"anonymous": false, "inputs": [], "name": "Unpause", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"pause()": {"details": "called by the owner to pause, triggers stopped state"}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}, "unpause()": {"details": "called by the owner to unpause, returns to normal state"}}, "title": "Pausable"}, "sources": {"keccak256": "0x2c92ef64d25ddba75a96b518ab3ad5211c4edab898ac2a693c300274ccd0c675", "swarm_URL": "bzzr://04335d6d25fbf30171a9ce1d458a570e58af99bf356aaeccc5ff1de1a93ae1b6"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n"}, {"name": "MyLib", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "MyLib", "author": "Gav Wouldn't", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "amount", "type": "uint256"}, {"name": "conversionRate", "type": "uint256"}], "name": "convert", "outputs": [{"name": "convertedAmount", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {"convert(uint256,uint256)": {"notice": "Converts given value to Ether value"}}}}, "endpoint": {}, "dev": {"devdoc": {"author": "Gav Wouldn't", "methods": {"convert(uint256,uint256)": {"return": "{ \"convertedAmount\" : \"Ether equivalent amount\" }"}}, "title": "Some Other Library"}, "sources": {"keccak256": "0xbe468f4d111cd6cb5690a89fbc45b6716f809a26e0b96c305d734ec91516ff6a", "swarm_URL": "bzzr://aa8420283df9f1626eb1cc26f03f0a262ac890a51fbb673e4642adb60c47b8b5"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\n/**\n@title Some Other Library\n@author Gav Wouldn't\n*/\nlibrary MyLib{\n\t/**\n\t@notice Converts given value to Ether value\n\t@param amount Token amount\n\t@param conversionRate Rate of conversion - Tokens -> Ether\n\t@return { \"convertedAmount\" : \"Ether equivalent amount\" }\n\t*/\n\tfunction convert(uint amount, uint conversionRate) returns (uint convertedAmount)\n\t{\n\t\treturn amount * conversionRate;\n\t}\n}\n"}]